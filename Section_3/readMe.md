Пример генерации всех возможных последовательностей длины n из нулей и единиц.

namespace Task_A;
class Program
{
    static void Main(string[] args)
    {
        GenBinary(3, "");
    }

    static void GenBinary(int n, string prefix)
    {
        if (n == 0)
        {
            Console.WriteLine(prefix);
        }
        else
        {
            GenBinary(n - 1, prefix + "0");
            GenBinary(n - 1, prefix + "1");
        }
    }
}

Превращение сортировки в стабильную
При помощи лексикографического порядка легко превратить любую сортировку в стабильную.
Для этого мы преобразуем каждый элемент исходного массива в тройку вида [значение ключа сортировки, позиция в исходном массиве, сам элемент]. 
Затем мы отсортируем массив таких троек.
Элементы, у которых значение ключа отличается, будут расположены в соответствии с этим ключом. 
Элементы, одинаковые по ключу, будут упорядочены по позиции в исходном элементе.
До сравнения по последнему элементу тройки дело не дойдёт, поскольку позиции у двух элементов совпасть не могут.
Например, чтобы отсортировать по длине слова ['Москва', 'Казань', 'Питер'], сохранив порядок слов одинаковой длины, сопоставим элементам тройки:
[[6,0,'Москва'], [6,1,'Казань'], [5,2,'Питер']]
При сортировке они будут упорядочены в порядке:
[5,2,'Питер'], [6,0,'Москва'], [6,1,'Казань'].
Восстановить порядок самих городов теперь можно тривиально, достаточно просто отбросить из троек лишнюю информацию.
В итоге получаем порядок ['Питер', 'Москва', 'Казань'].
Ключи сортировки в этих тройках сохранять не обязательно, их можно вычислять на лету. А вот исходные позиции сохранить придётся.
Поэтому такой способ сделать сортировку стабильной потребует 
O(n) дополнительной памяти.